/**
 * Level holds Level data,
 * will be renamed TileMap
 */

define(["./core", "./system","./Grid","./Point", "./Tile"],function(core, sys, Grid, Point, Tile){
	var screen= sys.screen;
	Level= Grid.extend({
		entities: [],
		tileSet: [],
		init: function(w, h){
			this._super(w,h);
			this.clearTo({t:0});
			this.tileSet.push( new Tile(false));
			this.tileSet.push( new Tile(true));
		},
		rndSize: function(){
			return 5 + core.random()*15;
		},
		rndPos: function(){
			var border = 25;
			var p = new Point(core.random()* (this.world.bounds.w),core.random()* (this.world.bounds.h) );
			p.x = Math.min(p.x, this.world.bounds.w-border);
			p.x = Math.max(p.x, border);
			p.y = Math.min(p.y, this.world.bounds.h-border);
			p.y = Math.max(p.y, border);
			return p;
		},
		test: function(){
			for(var i=0; i< 50; i++){
				r = Math.floor(Math.random()*this.width*this.height);
				this.dat[r]={t:1};
			}
		},
		getJson: function(){
			var s="{ ";
				s+= "width: " + this.width;
				s+= ", height: " + this.height;
				s+= ", dat: {" + this.dat.join(', ')+'}';
				s+= ", entities: {" + this.entities.join(', ')+'}';
				s+= ", tileSet: {" + this.tileSet.join(', ')+'}' ;			
			s+= "}";			
			
			return s;
		},
		update: function(){
			for(var i = 0; i < this.width*this.height; i++){
				this.dat[i].tested=false;
			}
		},
		draw: function(cam, w, h){			
			tw= Tile.getW();
			th= Tile.getH();
			
			off= new Point(cam.p.x/tw, cam.p.y/th);
			off.x= Math.floor(Math.max(0,off.x));
			off.y= Math.floor(Math.max(0,off.y));
			
			w= Math.min(Math.ceil(w/tw +1), this.width-off.x);
			h= Math.min(Math.ceil(h/th +1), this.height-off.y);

			for(var i = off.x; i < off.x+w; i++){
				for(j = off.y; j < off.y+h; j++){
					var p = new Point(i* tw, j*th);
					p= cam.toScreenPos(p);
					this.tileSet[this.get(i,j).t].draw(p);
					
					if(sys.debug && this.get(i,j).tested){
						screen.fill= screen.color(55,55,55);
						screen.stroke=0;
						screen.rect(p, tw/2,th/2);
					}
				}
			}
		},
		getTile: function(x,y){
			return {p: new Point(x*Tile.getW(), y*Tile.getH()), w: Tile.getW(), h: Tile.getH(),tile:this.get(x,y) , proto: this.tileSet[this.get(x,y).t]};
		},
		actualize: function(world){
			world.level=this;
			this.world= world;
			world.bounds= {x: 0, y: 0, w:this.width*Tile.getW(), h: this.height*Tile.getH()};
		}
	});
	return Level;
});